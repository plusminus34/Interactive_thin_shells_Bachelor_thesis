#include <RobotDesignerLib/FastMOPTPreplanner.h>
#include <MathLib/MathLib.h>
#include <ControlLib/QPControlPlan.h>

FastMOPTPreplanner::FastMOPTPreplanner(FastMOPTWindow* moptWindow){
	this->moptWindow = moptWindow;
}

FastMOPTPreplanner::~FastMOPTPreplanner(void){
}

void FastMOPTPreplanner::preplan(RobotState* currentRobotState) {
	startState = *currentRobotState;
	RobotState tmpState(moptWindow->robot);
	moptWindow->robot->setState(&startState);

	//first model the body as a particle moving under the influence of high level goals but with reasonable acceleration limits
	P3D currentBodyPos = currentRobotState->getPosition();
	V3D currentBodyVel = currentRobotState->getVelocity();
	double currentHeading = currentRobotState->getHeading();
	double currentTurningSpeed = currentRobotState->getAngularVelocity().dot(Globals::worldUp);

	comTrajectory.clear();
	comVelocityTrajectory.clear();
	headingTrajectory.clear();

	//we will be adding samples every 0.1s
	double dt = 0.1;
	for (double t = moptWindow->currentGlobalTime; t <= moptWindow->currentGlobalTime + moptWindow->preplanTimeHorizon; t += dt) {
		comTrajectory.addKnot(t, V3D() + currentBodyPos);
		comVelocityTrajectory.addKnot(t, currentBodyVel);
		headingTrajectory.addKnot(t, currentHeading);

		V3D targetSpeed =
			moptWindow->robot->forward * moptWindow->forwardSpeedTarget +
			moptWindow->robot->right * moptWindow->sidewaysSpeedTarget;

		double kp = 100;
		double kd = 20;

		targetSpeed = targetSpeed.rotate(currentHeading, Globals::worldUp);
		V3D acceleration = (targetSpeed - currentBodyVel) / dt;

		acceleration.setComponentAlong(Globals::worldUp,
			getTargetAcceleration_implicitPD(currentBodyPos.getComponentAlong(Globals::worldUp) - moptWindow->bodyHeightTarget, currentBodyVel.getComponentAlong(Globals::worldUp), kp, kd, dt)
		);

		boundToRange(acceleration.x(), -1, 1);
		boundToRange(acceleration.y(), -1, 1);
		boundToRange(acceleration.z(), -1, 1);

		currentBodyVel += acceleration * dt;
		currentBodyPos += currentBodyVel * dt;

//		Logger::consolePrint("t: %lf, vel: %lf\n", t, currentBodyVel.z());

		double headingAccel = (moptWindow->turningSpeedTarget - currentTurningSpeed) / dt;
		boundToRange(headingAccel, -1, 1);
		currentTurningSpeed += headingAccel * dt;
		currentHeading += currentTurningSpeed * dt;
	}

	//now handle the foot locations...

	eeTrajectories.clear();

	cffp = ContinuousFootFallPattern();

	auto eeTraj = moptWindow->locomotionManager->motionPlan->endEffectorTrajectories;
	for (uint i = 0; i < eeTraj.size(); i++) {
		eeTrajectories.push_back(Trajectory3D());
		eeTrajectories[i].addKnot(moptWindow->currentGlobalTime, V3D() + eeTraj[i].endEffectorRB->getWorldCoordinates(eeTraj[i].endEffectorLocalCoords));
		cffp.addStepPattern(eeTraj[i].theLimb);
	}

	cffp.populateFrom(moptWindow->defaultFootFallPattern, moptWindow->defaultFFPStrideDuration, moptWindow->currentGlobalTime, moptWindow->currentGlobalTime + moptWindow->preplanTimeHorizon);
	for (uint i = 0; i < eeTraj.size(); i++) {
		//we must determine the stance phases for each limb
		double t = moptWindow->currentGlobalTime;
		bool eeStartsInStance = false;

		while (t < moptWindow->currentGlobalTime + moptWindow->preplanTimeHorizon){
			double stancePhaseStart = cffp.stepPatterns[cffp.getStepPatternIndexForLimb(eeTraj[i].theLimb)].getFirstTimeInStanceAfter(t);
			double stancePhaseEnd = cffp.stepPatterns[cffp.getStepPatternIndexForLimb(eeTraj[i].theLimb)].getFirstTimeInSwingAfter(stancePhaseStart+0.01);

			//make sure there is another swing phase to reason about...
			if (stancePhaseEnd > stancePhaseStart) {

				//we will place the stance end effectors in the middle of the trajectory generated by the body...
				P3D localCoordsEEPos = eeTraj[i].rootToEEOriginalOffset_local;
				P3D eePosAtStancePhaseStart = comTrajectory.evaluate_linear(stancePhaseStart) + (V3D() + localCoordsEEPos).rotate(headingTrajectory.evaluate_linear(stancePhaseStart), Globals::worldUp);
				P3D eePosAtStancePhaseEnd = comTrajectory.evaluate_linear(stancePhaseEnd) + (V3D() + localCoordsEEPos).rotate(headingTrajectory.evaluate_linear(stancePhaseEnd), Globals::worldUp);

				//now, decide where this stance location should be in world coordinates (assuming the leg wasn't in stance to begin with)
				if (stancePhaseStart > moptWindow->currentGlobalTime) {
					P3D worldEEPos = (eePosAtStancePhaseStart + eePosAtStancePhaseEnd) / 2.0;
					worldEEPos.setComponentAlong(Globals::worldUp, 0);
					eeTrajectories[i].addKnot(stancePhaseStart, worldEEPos);
					eeTrajectories[i].addKnot(stancePhaseEnd, worldEEPos);
				}
				else {
					eeStartsInStance = true;
					//the leg started off in stance, so make sure it remains in stance long enough...
					eeTrajectories[i].addKnot(stancePhaseEnd, V3D() + eeTraj[i].endEffectorRB->getWorldCoordinates(eeTraj[i].endEffectorLocalCoords));
				}

				t = stancePhaseEnd + 0.01;
			}
			else
				t = moptWindow->currentGlobalTime + moptWindow->preplanTimeHorizon + 0.01;
		}

		//the stance phases are all in there, so now add the swing phases too...
		int count;
		if (eeStartsInStance) 
			count = 0;
		else {
			count = 1;
			//if the end effector starts out in swing, then we need to make sure the height profile is still ok
			double swingPhaseAtStart = cffp.stepPatterns[cffp.getStepPatternIndexForLimb(eeTraj[i].theLimb)].getSwingPhase(moptWindow->currentGlobalTime);
			if (swingPhaseAtStart < 0) Logger::consolePrint("Uh-oh, we have a problem...\n");
			if (swingPhaseAtStart < 0.5) {
				double timeToGroundStrike = cffp.stepPatterns[cffp.getStepPatternIndexForLimb(eeTraj[i].theLimb)].getFirstTimeInStanceAfter(moptWindow->currentGlobalTime) - moptWindow->currentGlobalTime;
				double swingDuration = timeToGroundStrike / (1 - swingPhaseAtStart);
				double timeToMidSwing = timeToGroundStrike - 0.5 * swingDuration;
				P3D eePosMidSwing = (eeTrajectories[i].getKnotValue(0) + eeTrajectories[i].getKnotValue(1)) / 2.0;
				eePosMidSwing.setComponentAlong(Globals::worldUp, moptWindow->moptParams.swingFootHeight);
				eeTrajectories[i].addKnot(timeToMidSwing, V3D() + eePosMidSwing);
				count = 2;
			}
		}
		for (count; count < eeTrajectories[i].getKnotCount()-2; count+=3) {
			P3D eePosMidSwing = (eeTrajectories[i].getKnotValue(count+1) + eeTrajectories[i].getKnotValue(count+2))/2.0;
			double t = (eeTrajectories[i].getKnotPosition(count + 1) + eeTrajectories[i].getKnotPosition(count + 2)) / 2.0;
			eePosMidSwing.setComponentAlong(Globals::worldUp, moptWindow->moptParams.swingFootHeight);
			eeTrajectories[i].addKnot(t, V3D() + eePosMidSwing);
		}
	}

	moptWindow->robot->setState(&tmpState);

//visualize the motion plan with some IK and drawn robot states along the way
//have a play through where time advances and starting from where the robot is the motion plan gets reinitialized/updated, and we should see it being coherent and just growing...
}

void FastMOPTPreplanner::getRobotStateAt(double t) {

}

void FastMOPTPreplanner::draw() {
	glColor3d(1,0,0);

	RobotState tmpState(moptWindow->robot);
	moptWindow->robot->setState(&startState);
	moptWindow->robot->draw(SHOW_ABSTRACT_VIEW);
	moptWindow->robot->setState(&tmpState);

//	drawArrow(P3D(0, 1, 0), V3D(-1, 0, 0), 0.01);

	double dt = 0.1;
	glBegin(GL_LINE_STRIP);
	for (double t = moptWindow->currentGlobalTime; t <= moptWindow->currentGlobalTime + moptWindow->preplanTimeHorizon; t += dt) {
		P3D pos = comTrajectory.evaluate_linear(t);
		glVertex3d(pos.x(), pos.y(), pos.z());
	}
	glEnd();

	glColor3d(0, 0, 1);
	dt = 0.01;
	for (uint i = 0; i < eeTrajectories.size(); i++) {
		glBegin(GL_LINE_STRIP);
		for (double t = moptWindow->currentGlobalTime; t <= moptWindow->currentGlobalTime + moptWindow->preplanTimeHorizon; t += dt) {
			P3D pos = eeTrajectories[i].evaluate_linear(t);
			glVertex3d(pos.x(), pos.y(), pos.z());
		}
		glEnd();
	}

	glColor3d(1, 0, 0);
	dt = moptWindow->preplanTimeHorizon / 20.0;
	for (double t = moptWindow->currentGlobalTime; t <= moptWindow->currentGlobalTime + moptWindow->preplanTimeHorizon; t += dt) {
		P3D pos = comTrajectory.evaluate_linear(t);
		drawSphere(pos, 0.01);
		V3D forward = moptWindow->robot->forward.rotate(headingTrajectory.evaluate_linear(t), Globals::worldUp);
		drawArrow(pos, forward*0.05, 0.0025);
	}

}

